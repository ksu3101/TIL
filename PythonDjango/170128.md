# 파이썬 기본기 익히기 세번째 

## 1. `if-else` 문 

`if`와 `else`를 이용 하여 프로그래밍에서 조건을 보고 판단 하여 상황에 맞춘 분기를 해 보자. 

상황에 따라서 분기를 해야 하는 예를 말하면 이런 경우가 있을 것 이다. 어떠한 값이 `100`일 경우 100이 맞고 그 외에는 아니다 라고 출력 하는 프로그램이 있다. 이 경우 주어진 값이 `100`인지를 검사 하고 맞다면 그에 해당하는 상황을 출력 하고, 틀리다면 또 그에 해당하는 상황을 출력 해야 한다. 이를 정리 하면 다음과 같다. 

- 값을 입력 받는다. 
- 입력받은 값이 100이 맞다면 `값이 100이다` 를 출력 한다. 
- 입력받은 값이 100이 아니라면 `값이 1000이 아니다`를 출력 한다. 

위 상황을 코드로 구현해 보면 아래와 같다. 

```py
value = 90
if value == 100:
    print("값이 100 이다")
elif value == 90:
    print("값이 90 이다")
else:
    print("값이 100이 아니다")
```

주어진 값 변수인 `value`에서는 100으로 값을 초기화 한다. 그리고 `if` 문을 이용 하여 `value`변수의 값이 `100`인지 검사 한다. 맞다면 `값이 100 이다`를 출력 한다. 

만약 값이 `100`이 아니고 `90`일 경우에는 `elif`문에서 처리 하게 된다. 이 구문은 `else if`의 줄임이다. 

만약 주어진 값이 100이 아닌 모든 경우를 `else`문 아래에서 처리 하고 있다. 이 경우 `값이 100이 아니다`를 출력하고 있다. 

### 1.1. `if-else` 의 구조 

`if`와 `else`를 이용 하는 구조는 아래와 같다. 

```py 
# 기본 구조
if 조건문:
    실행_1
    실행_2
    ...
elif 조건문2:
    실행_1
    실행_2
    ...
else:
    실행_1
    실행_2
    ...
```

구조에서 보듯이 가장 중요 한 점은 `if`, `elif`, `else`로 이루어져 있으며 `:`과 들여쓰기를 통해서 조건문과 실행구문이 구분 된다. 조건에 해당하는 구문과 다른 일반적인 소스 라인의 구분에서 보통 다른 언어에서는 `{}`로 구분 하지만 파이썬에서는 **들여쓰기**로 구분 한다. 그 예로 다음 소스를 보자. 

```py
value = 100
if value == 100:
    print("값이 100 입니다. ")
  print("100을 입력하셨군요.")
else:
    print("값이 100이 아닙니다.")
```

소스에서 *4*번째 라인을 보면 기존 들여쓰기와는 다르다는것을 알 수 있다. 이런경우 실행 시키면 아래와 같은 오류가 발생 한다. 

```
  File ".../ifStudy.py", line 14
    print("100을 입력하셨군요.")
                         ^
IndentationError: unindent does not match any outer indentation level
```

`if-else`문을 이용 할때에는 들여쓰기가 매우 중요 하다. 보통 다른 언어에서는 들여쓰기에 대해서는 의존성이 없어 보통 들여쓰기에 사용 되는 문자를 `space`문자 나 `tab`문자를 사용 하는데 아무런 문제가 없지만 파이썬에서는 조금 신경 쓰이는 문제이다. 일반 적인 스페이스문자를 사용할 경우 백스페이스키를 잘못 눌러서 공간이 하나만이라도 줄어들면 컴파일이 안되는 문제가 발생 하기 때문이다. 

### 1.2 조건문의 구성 

조건문을 구성하는 방법에대해서 더 알아보자. 조건문에서 조건을 판단 하는 방법은 `True`와 `False`이다. 이는 일반적인 **참** 과 **거짓** 으로서, 이를 통해서 상황에 맞추어 분기 하는 것 이다. 아래 예제 소스를 보자. 

```py
intValueTrue = 10
intValueFalse = 0

if intValueTrue:
    print("주어진 값은 %d입니다." % intValueTrue)
if intValueFalse:
    print("주어진 값은 %d입니다." % intValueFalse)
if intValueTrue == 10:
    pass
elif intValueFalse == False:
    print("주어진 값은 거짓으로 판명된 %d입니다." % intValueFalse)
```

입력 받은 두개의 정수형 변수 `intValueTrue`와 `intValueFalse`가 있다. `pass`구문은 조건에 대해서 참 일경우 무시 하고 다음 조건문을 보거나 조건문을 빠져나가게 해 주는 것 이다. 

위 조건문들에 대한 결과는 아래와 같다. 

```
주어진 값은 10입니다.
주어진 값은 거짓으로 판명된 0입니다.
```

`intValueTrue`는 정상적으로 첫번째 조건문에서 값이 출력 되었다. 하지만 `intValueFalse`를 판단 하는 조건문에서는 2번째가 아니라 3번째로 갔다. 주어진 값은 `0`인데 왜 `False`로 판명이 난 것일까? 

파이썬에서는 어떠한 자료형에 대해서 참과 거짓의 판단을 자체적으로 하고 있다. 그 예는 아래 도표를 참고 해 보자. 

자료형 | `True` | `False` 
--- | --- | --- 
숫자 | 0 이 아닌 모든 숫자 | `0`
String | 길이가 0보다 큰 문자열 | `""` (길이가 0인 문자열)
List | 원소가 하나 이상 존재하는 리스트 | `[]` (원소가 없는 리스트)
Tuple | 원소가 하나 이상 존재하는 튜플 | `()` (원소가 없는 튜플) 
Dictionarie | 키-원소 쌍이 하나 이상 존재 하는 딕셔너리 | `{}` (키-원소 쌍이 없는 딕셔너리) 

### 1.3 비교 연산자 

조건이 참인지 거짓인지 판단 하기 위해서는 비교 연산자들을 사용 해서 구분 한다. 위 예제 소스에서 `==`와 같은 연산자들을 말한다. 아래 도표를 참고 하자. 

비교연산자 | 설명 
--- | --- 
`x < y` | `x` 값이 `y`보다 작다. 
`x > y` | `x` 값이 `y`보다 크다. 
`x == y` | `x` 값과 `y`이 같다. 
`x != y` | `x` 값과 `y`이 같지 않다. 
`x <= y` | `x` 값이 `y`와 같거나 작다. 
`x >= y` | `x` 값이 `y`와 같거나 크다. 

위 도표의 비교연산자를 활용한 조건문의 예는 아래와 같다. 

```py 
value = 120
if value == 120:
    print("값은 120 이다")
if value != 100:
    print("값은 100이 아니다")
if value > 100:
    print("값은 100보다 크다")
if value < 900:
    print("값은 900보다 작다")
if value >= 120:
    print("값은 120보다 같거나 크다")
if value <= 900:
    print("값은 900보다 같거나 작다")
```

실행 한 결과는 아래와 같다. 대부분의 상황이 `True`이기 때문에 모두 출력하는 것을 확인할 수 있다. 

```
값은 120 이다
값은 100이 아니다
값은 100보다 크다
값은 900보다 작다
값은 120보다 같거나 크다
값은 900보다 같거나 작다
```

간단한 예제를 해 보자. 

`만약 5000원 이상을 가지고 있다면 택시를 탄다. 하지만 5000을 갖지 못하고 2000을 갖고 있다면 지하철을 탄다. 그리고 그보다 더 적다면 그냥 걸어서 간다.`

위 예제를 소스로 작성 하면 아래와 같다. 

```py 
money = 5000
if money >= 5000:
    print("택시를 타고 가자!!")
elif money == 2000:
    print("지하철을 타고 가자!!")
elif money < 2000:
    print("걸어 가자..")
```

입력한 금액 변수인 `money`의 값에 따라서 분기가 달라질 것 이다. 

### 1.4 `and, or, not` 연산자 

다른 비교 연산자로서 `and`, `or`, `not` 이 있다. 이름에서 알 수 있듯이 양 변의 참 거짓을 확인 하는 연산자 이다. 

연산자 | 설명 
--- | --- 
`x and y` | x 와 y 둘 다 `True` 일 경우에만 `True`가 된다. 만약 둘중 하나라도 `False`가 있다면 `False`가 된다. 
`x or y` | x 와 y 둘 중 하나 이상이 `True` 일 때만 `True`가 된다. 하지만 둘 다 `False`라면 `False`가 된다. 
`not x` | x 가 `False`라면 `True` 이다. 

이는 예제소스를 보는게 더 빠르다. 

```py 
value = 100
strValue = ""
if value == 100 and value != 900:
	print("값은 정확히 100 이면서 900은 절대로 아니다.")
if value != 50 or value >= 100:
	print("값은 50이 아니거나 100보단 크거나 같다.")
if not value:
	print("값인 False(0)이 아니다.")
if not strValue:
	print("문자열이 현재 비어 있다.")
if not value == 900:
	print("값이 900 이 아니다.")
```

실행 결과는 다음과 같다. 

```
값은 정확히 100 이면서 900은 절대로 아니다.
값은 50이 아니거나 100보단 크거나 같다.
문자열이 현재 비어 있다.
값이 900 이 아니다.
```

첫번째 조건문은 `value == 100 and value != 900` 인데 `value`의 값이 100 이면서 900이 아니라는 것 이다. 두 조건을 모두 만족하는 조건 이기 때문에 `True`가 되어 실행구문을 실행 하여 결과를 출력 하는 것을 알 수 있다. 

두번째 조건문은 `value != 50 or value >= 100` 인데 `value`의 값이 50 이 아니거나 100보다 크거나 같다 이다. 첫번째 조건에는 해당하지 않지만 두번째 조건에 해당 하므로 실행 구문을 실행하여 결과를 출력 한다. 

세번째 조건에서는 `not value`인데 `value`가 `False`일 경우에 결과를 출력 한다. 하지만 `value`의 값은 100 이기 때문에 `True` 상태가 된다. 만약 0 이라면 `False`가 되기 때문에 실행 구문을 실행 하지만 지금의 경우 `True`이기 때문에 실행 구문을 실행 하지 않고 넘어 간다. 

네번째 조건에서는 `not strValue`인데 `strValue`라는 변수는 비어있는 문자열 이다. 이는 `False`상태 이기 때문에 조건에 대해서는 `True`상태가 되어 실행구문을 실행하여 결과를 출력 한다. 

다섯번째 조건에서는 `not value == 900`이다. 여기에서 `value`변수는 100 이라는 값 이기 때문에 조건문에 대해서는 `True`상태 가 된다. 그렇기 때문에 실행구문을 실행하여 결과를 출력 한다. 

### 1.5 `in, not in` 연산자 

`in`과 `not in` 비교 연산자는 어떠한 리스트나 튜플, 딕셔너리 와 같은 자료 구조에 원소로 존재 하는지 혹은 존재하지 않는지 확인 하는 연산자 이다. 사용 예는 아래 예제 소스를 확인 해 보자. 

```py 
print("1 은 [1, 2, 3] 리스트 안에 존재 하는가? %s " % (1 in [1, 2, 3]))
print("`A` 는 (`K`, `C`, `D`) 튜플 안에 존재 하는가? %s " % ('A' in ('K', 'C', 'D')))
print("500 은 [100, 200, 300] 리스트 안에 존재하지 않는가?  %s " % (500 not in [100, 200, 300]))
print("`Kang` 은 [`Kim`, `Kang`, `Jang`] 리스트 안에 존재하지 않는가? %s " % ("Kang" not in ["Kim", "Kang", "Jang"]))
print("'D'는 'PythonDjango 문자열에 존재 하는 문자인가? %s " % ('D' in "PythonDjango"))
```

실. 

```
1 은 [1, 2, 3] 리스트 안에 존재 하는가? True 
`A` 는 (`K`, `C`, `D`) 튜플 안에 존재 하는가? False 
500 은 [100, 200, 300] 리스트 안에 존재하지 않는가?  True 
`Kang` 은 [`Kim`, `Kang`, `Jang`] 리스트 안에 존재하지 않는가? False 
'D'는 'PythonDjango 문자열에 존재 하는 문자인가? True 
```

`in` 이나 `not in`의 뜻을 생각해 보면 간단 하다. 어떠한 리스트나 튜플 같은 자료 형에서 찾는 원소가 존재하는지 여부를 판단 하는 것 이다. 

첫번째 연산자의 경우 `1`이라는 숫자가 `1, 2, 3`이 존재 하는 리스트 내부에 원소로 존재하는지 확인 하는 것 이다. 실제로 원소가 리스트에 존재 하기 떄문에 `True`를 출력 하는 것 을 알 수 있다. 

두번째의 경우 `A` 라는 문자가 `K, C, D` 문자 들로 이루어진 튜플 안에 존재하는지 확인 한다. 이 튜플에는 `A`라는 문자가 없기 때문에 `False`를 출력 하는 것을 알 수 있다. 

마지막 연산의 경우 `PythonDjango`라는 문자열에서 `D`문자가 존재하는지 확인 하는 연산 이다. 실제로 `D`는 문자열 내에 존재 하기 때문에 `True`를 출력 한다. 

### 1.6 `if-else`를 한줄로 사용 해 보기 

하나의 조건문에 실행구문이 한줄로 존재 한다면 간단히 두 라인을 한 라인에 작성하여 사용 하는 방법이 있다. 아래 예제 소스를 보자. 

```py 
value = 10
if value == 10: print("값은 10 이다.")
else: print ("값은 10이 아니다")
```

`if`와 조건문, 그리고 실행 구문이 한 라인에서 사용 된 것을 확인 할 수 있다. 이렇게 작성 하는 경우 한눈에 조건에 해당하는 실행구문이 보이므로 편하게 느껴질 수도 있다. 

## 2. `while` 문

소스를 작성 하다 보면 어떠한 실행구간이 반복되는 경우가 있다. 이러한 반복 구간을 다루기 위해서는 반복제어문을 사용 하면 되는데 그 중 하나인 `while`문에 대해서 알아 보자. 

### 2.1 `while`문의 구조 

`while`문의 구조는 아래와 같이 간단 하다. 

```py
while 조건문:
    실행_1
    실행_2
    ...
``` 

구조에 대해서 설명 하면 이렇다. `while`문 과 `:` 사이의 조건문에서는 반복을 실행 하는지에 대한 여부인 `True`, `False`를 반환하는 조건 문이 들어간다. `if`문에서 사용 해본 조건 문과 동일 하다고 생각 하면 된다. 다음의 예제를 보자. 

```py
index = 1
while index <= 10:
	if index < 10:
		print("index 값은 %d 입니다." % index)
	else:
		print("index 값이 %d 입니다. 마지막 숫자 입니다." % index)
	index += 1
```

이 예제 소스의 실행 결과는 다음과 같다. 

```
index 값은 1 입니다.
index 값은 2 입니다.
index 값은 3 입니다.
index 값은 4 입니다.
index 값은 5 입니다.
index 값은 6 입니다.
index 값은 7 입니다.
index 값은 8 입니다.
index 값은 9 입니다.
index 값이 10 입니다. 마지막 숫자 입니다.
```

실행 후 초기 세팅 된 `index`의 값이 10보다 작거나 같을 때 까지 반복을 수행 한다. 수행할 반복의 내용은 `index`의 값이 10이 아닐 경우 어떠한 문자열을 출력 하지만 마지막 숫자인 10일 경우에는 마지막 숫자임을 알리고 종료 하는 소스 이다. `index`의 값은 한번 반복 할 때마다 값이 계속 증가 하는 `index += 1`에 조심 하자. 

이 예제의 실행 흐름을 정리하면 다음과 같다. 

index | 조건문 | 조건문에 대한 결과 | 출력되는 문자열 | `while`문의 상태 
--- | --- | --- | --- | --- 
1 | 1<=10 | `True` | index 값은 1 입니다. | 실행중 
2 | 2<=10 | `True` | index 값은 2 입니다. | 실행중 
3 | 3<=10 | `True` | index 값은 3 입니다. | 실행중 
4 | 4<=10 | `True` | index 값은 4 입니다. | 실행중 
5 | 5<=10 | `True` | index 값은 5 입니다. | 실행중 
6 | 6<=10 | `True` | index 값은 6 입니다. | 실행중 
7 | 7<=10 | `True` | index 값은 7 입니다. | 실행중 
8 | 8<=10 | `True` | index 값은 8 입니다. | 실행중 
9 | 9<=10 | `True` | index 값은 9 입니다. | 실행중 
10 | 10<=10 | `True` | index 값은 10 입니다. | 실행중 
11 | 11<=10 | `False` | "" | 반복 종료 

만약 이러한 소스를 `if-else`로 작성 하려면 최소한 11라인이 필요 하다. 하지만 `while`문 같은 반복제어문을 사용 하면 매우 간단하게 사용 할 수 있다. 

### 2.2 `continue` 와 `break` 

`while`반복문을 사용 하게 할 경우 특정 상황에 맞추어 반복을 멈추게 하거나 다음 반복문 흐름으로 강제로 넘기는 방법이 있다. 다음 예제 소스를 보자. 

```py 
index = 0
while index <= 10:
	if index == 2:
		index += 1
		continue 	# index 가 2일땐 index를 증가 시키고 다음 반복으로 진행
	elif index == 9:
		print("index 가 9일땐 강제 종료 합니다. ")
		break
	else:
		print("index 값은 %d 입니다." % index)
	index += 1
```

실행 결과는 다음과 같다. 

```
index 값은 0 입니다.
index 값은 1 입니다.
index 값은 3 입니다.
index 값은 4 입니다.
index 값은 5 입니다.
index 값은 6 입니다.
index 값은 7 입니다.
index 값은 8 입니다.
index 가 9일땐 강제 종료 합니다. 
```

실행 흐름을 정리 하면 다음과 같다. 

index | 조건문 | 조건문에 대한 결과 | 출력되는 문자열 | `while`문의 상태 
--- | --- | --- | --- | --- 
1 | 1<=10 | `True` | index 값은 1 입니다. | 실행중 
2 | 2<=10 | `True` | "" | 실행중 이지만 `index`만 1 증가시키고 다음 반복으로 `continue`
3 | 3<=10 | `True` | index 값은 3 입니다. | 실행중 
4 | 4<=10 | `True` | index 값은 4 입니다. | 실행중 
5 | 5<=10 | `True` | index 값은 5 입니다. | 실행중 
6 | 6<=10 | `True` | index 값은 6 입니다. | 실행중 
7 | 7<=10 | `True` | index 값은 7 입니다. | 실행중 
8 | 8<=10 | `True` | index 값은 8 입니다. | 실행중 
9 | 9<=10 | `True` | index 가 9일땐 강제 종료 합니다.  | `break`로 인해 문자열 출력 하고 반복 강제 종료 

`continue`제어문은 반복 중 어떤 특정 조건의 흐름에서 `continue`문을 만나기 전까지의 실행 구문만 실행하고 바로 다음 반복 흐름으로 넘어간다. `continue`문 전에 `index += 1`을 넣은 이유는 `continue`를 만날 경우 바로 다음 반복 흐름으로 넘어가는데 하단의 `index += 1`까지 실행 흐름이 가지 않기 때문에 `continue`문 전에 `index`만 1 증가 시키고 다음 흐름으로 넘어간 것 이다. 그렇기 때문에 아래에 존재 하는 출력실행을 하지 않고 넘어 간다. 

`break`제어문은 반복 중 어떤 특정 조건의 흐름에서 `break`문을 만나기 전까지의 실행 구문만 실행하고 반복을 강제로 종료 한다. 
`continue`와 `break`는 사용법은 같지만 기능은 완전히 서로 다르다. 그렇기 때문에 사용에 있어 주의를 요한다. 특히 이런 반복문에서 가장 조심해야 할 것은 **무한 반복**되는 경우 이다. 

### 2.3 무한 반복 

위에서 무한 반복에 대해서 조심해야 한다고 했었다. 하지만 어떤 반복을 무한으로 해놓고 특정 조건에 `break`문을 활용 하여 반복을 종료 시킨 다면 루틴을 문제 없이 잘 작성만 했다면 이러한 기법은 많이 사용되곤 한다. 다음 예제 소스를 보자. 

```py 
index = 1
while True:
	if index == 10:
		print("index 값은 10 입니다. 반복을 종료 합니다.")
		break
	print("index 값은 %d 입니다." % index)
	index += 1
```

실행 결과는 다음과 같다. 

```
index 값은 1 입니다.
index 값은 2 입니다.
index 값은 3 입니다.
index 값은 4 입니다.
index 값은 5 입니다.
index 값은 6 입니다.
index 값은 7 입니다.
index 값은 8 입니다.
index 값은 9 입니다.
index 값은 10 입니다. 반복을 종료 합니다.
```

자세히 보면 `while`문의 조건에 `True`만 들어가 있다. 이런 경우 조건문에 설정 된 `True`라는 값이 영원히 바뀌지 않기 때문에 이 반복문은 영원히 계속 반복 할 것이다. 이런 경우 문제가 발생 하고 실행되는 프로그램은 죽지 않고 계속 혼자서 실행 할 것이다. 이런 경우 CPU와 메모리의 자원을 계속 갉아먹기 떄문에 문제가 발생 한다. 

하지만 `break`문을 통해서 `index`값이 10일 경우 강제로 반복을 종료 하게 했다. 정확히 10번 반복 하고 종료 하는 것을 출력되는 문자열을 통해서 확인 할 수 있다. 

무한반복문은 몇번 반복될지 예측 불가능한 상황에서 특정 종료 시점에 대한 조건을 알고 있고 그게 명확하다면 문제 없이 사용 할 수 있다. 몰론 잘못된 루틴과 조건문으로 실행 하면 이러한 무한 반복은 말그대로 끝나지 않고 계속 혼자서 반복 할 것이다. 그렇기 떄문에 사용에 매우 주의를 요한다. 

## 2.4 `while`문을 중첩 하여 사용 하기 

`while`문을 2개 사용 하여 반복문 안에서 반복을 하게 되면 어떻게 될까. 다음 구구단을 계산하여 출력 하는 소스를 한번 보도록 하자. 

```py 
x = 1
y = 1
while x <= 9:
	if y == 10: y = 0
	while y <= 9:
		print("%d * %d = %d" % (x, y, x * y))
		y += 1
	x += 1
```

실행 결과는 다음과 같다. 일부 반복 되는 영역이 있어 생략 하였다. 

```
1 * 1 = 1
1 * 2 = 2
1 * 3 = 3
1 * 4 = 4
1 * 5 = 5
1 * 6 = 6
1 * 7 = 7
1 * 8 = 8
1 * 9 = 9
2 * 0 = 0
2 * 1 = 2
 ... 
8 * 9 = 72
9 * 0 = 0
9 * 1 = 9
9 * 2 = 18
9 * 3 = 27
9 * 4 = 36
9 * 5 = 45
9 * 6 = 54
9 * 7 = 63
9 * 8 = 72
9 * 9 = 81
```

편하게 **바깥 반복문** 과 **내부 반복문** 이렇게 구분 하도록 하겠다. 바깥 반복문 에서는 `x`의 값을 보며 내부 반복문 에서는 `y`의 값을 본다. 

바깥 반복문 에서는 `x`의 값이 9보다 작거나 같을때까지 반복 한다. 이때 x의 증가 시점은 내부 반복문이 종료 된 시점에 1씩 증가 된다. 

안쪽 반복문 에서는 `y`의 값이 9보다 작거나 같을때까지 반복 한다. 그리고 `x`와 `y`의 값을 곱하여 그 결과들을 출력 하고 `y`또한 1 증가 한다. 

안쪽 반복문에서 계속 값이 증가 하여 9보다 큰 10이 되었을 경우 안쪽 반복문은 종료 한다. 문제는 이값은 계속 10이기 때문에 다음 바깥 반복문의 다음 실행 흐름에서 이를 다시 0으로 초기화 시켜 준다. 그렇기 때문에 `y`값을 보는 안쪽 반복문이 실행 되게 되는 것 이다. 보기에는 복잡해 보이지만 이러한 형태의 소스를 많이 작성 해 보면 알 수 있다. 

반복문 하나를 사용 하는것은 나쁘진 않다. 실행 시간 과 메모리 사용량에 대해서 말이다. 조건문에서 `n`번까지 실행 하라 그러면 이 반복문의 실행 시간은 `n`만큼 일 것이며 메모리 사용량도 같다. 그보다 더 늦게 그리고 더 많은 메모리를 사용 하지 않는다. 하지만 반복문에 반복문을 중첩하면 이야기가 달라 진다. 

반복문 중첩의 경우 `n` 에서 `n`만큼 증가될 최악의 수가 생긴다. 이런 경우 `n`의 제곱수 까지 시간과 메모리를 점유 하기 때문에 `n`만큼만 반복 하는 것 보다 효율이 매우 좋지 않다. 이런 경우 알고리즘을 잘 고민 하여 반복문을 잘 제어 하는 기술이 필요한 것 이다. 

## 3. `for` 문



