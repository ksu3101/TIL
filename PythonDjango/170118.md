# 파이썬 기본기 익히기 두번째 

## 1. 리스트 (List)

리스트(List) 자료형은 어떠한 데이터들의 선형적(Linear)인 모음을 표현 하는 방법들 중 하나 이다. 예를 들어 짝수들의 목록 인 `2, 6, 8, 12, 16, 22` 가 존재 할 경우 이러한 숫자의 표현을 파이썬에서 표현하면 아래와 같다. 

```py
evenNumbers = [2, 6, 8, 12, 16, 22]
```

자세히 보면 원소들을 대괄호인 `[, ]`로 감싸고 `,`쉼표 글자로 각 원소를 구분하고 있음을 확인 할 수 있다. 또한 리스트의 표현은 여러가지로 존재 할 수 있는데 그 예로 아래와 같이 표현할 수 있다. 

```py
list1 = []
list2 = [1, 2, 3]
list3 = ['kang', 'kim', 'park']
list4 = ['kim', 100, 0.15, 'lee']
list5 = [1, ['kim', 'jung', 'lee'], 2, 3]
```

1번째 리스트 처럼 원소가 존재하지 않는 리스트도 있으며 문자열이나 숫자, 다른 자료형을 가진 리스트도 존재 할 수 있다. 그리고 4번째 리스트 처럼 리스트 내에 다른 리스트를 존재 할 수 있다. 이는 리스트 내부에서는 어떠한 자료형을 모두 사용 할 수 있는 것 이다. 

## 1.1 리스트의 인덱스 처리  

연속된 문자의 목록으로 이루어진 문자열의 인덱스 처리 처럼, 어떠한 원소들의 모임인 리스트도 인덱스로 접근 할 수 있으며 이에 대해 편집 할 수 있는 기능들을 제공 한다. 

예를 들어, 

```py
list = ['kim', 'lee', 'park', 'kang']
```

위와 같은 원소를 가진 리스트에서 0번째 인덱스를 표현 하는 `list[0]`은 `kim`이다. 그리고 2번째 인덱스인 `list[2]`의 경우에는 `park`를 가르킨다. 

만약 위 원소들에 대해서 `list[0]`과 `list[2]`를 더하는 연산인 `+`을 수행하면 어떻게 될까? 

```py
print(list[0] + list[2])
```

그 결과는 `kimpark`를 출력 한다. 0분째 원소인 `kim`과 2번째 원소인 `park`를 붙여서 출력 하게 된다. 몰론 다른 자료형에서는 그에 맞는 연산을 수행 할 것 이다. 예를 들어 숫자로 이루어진 원소의 `+`연산일 경우 숫자의 합 결과를 출력 할 것 이다. 

그렇다면 리스트에서 마지막 원소를 얻는 방법은 무엇일까? 리스트의 길이를 알 수 없는 런타임 환경에서 어떻게 마지막 원소를 얻어서 사용 할 수 있을까? 
그 예제로 아래와 같은 코드와 그에 대한 결과를 보면 아래 내용들과 같다. 

```py
strList = ['kim', 'lee', 'park', 'kang']
print(strList[-1])
testList = [1, 4, 6, 12, 20]
print(testList[-1])
testList2 = [5, 6, 7, ['kang', 'lee']]
print(testList2[-1])
```

실행한 결과는 다음과 같다. 

```
kang
20
['kang', 'lee']
```

`[-1]`를 이용 하여 리스트의 마지막 원소에 접근 한다. 위의 코드와 그 결과를 통해 확인 할 수 있다. 리스트 안에 리스트가 존재 하는 `testList2`의 경우 마지막 원소로 존재 하는 리스트를 가져와 출력 하는 것 을 확인 할 수 있다. 

그렇다면 위와 같이 리스트내 리스트를 가져오고 그 리스트에 대한 인덱스의 처리를 간단히 하는 방법은 어떻게 할까? 그 방법은 아래와 같다. 

```py
print(testList2[-1][1])
```

실행한 결과는 `lee`를 출력 한다. `[-1]`을 이용 하여 마지막 원소 리스트에 접근 한 뒤 그 리스트에서 `[1]`번째의 인덱스 원소에 접근하여 출력하는 것 을 확인 할 수 있다. 몰론 이와 비슷한 방법으로 리스트가 여러개 중첩인 경우 비슷한 방식으로 접근 할 수 있다. 

## 1.2 리스트의 연산 처리 

### 1.2.1 리스트들을 더하거나 반복 하기 

주어진 리스트를 이용 하여 `+` 기호를 이용 하여 리스트 들을 합치는 기능을 수행 할 수 있으며, `*` 기호를 이용 하여 리스트를 반복 시킬 수 있다. 

```py
aList = [1, 2, 3, 4]
bList = [5, 6, 7, 8]

# 리스트 더하기
print(aList + bList)

# 리스트 반복
print(aList * 2)
print(bList * 3)
``` 

### 1.2.2 리스트 원소의 수정과 함수 사용방법 

- 리스트 원소의 수정 

리스트에 속해있는 원소를 수정하는 방법은 간단 하다. 해당 원소의 인덱스에 접근 하여 값을 대입 시켜 주면 된다. 

```py 
# 리스트에서 원소 수정 하기
elist = [3, 5, 6]
elist[1] = 100
print(elist)
```

위에서 `elist`리스트의 1번째 인덱스의 원소의 값을 `5`에서 `100`으로 변경 하였다. 출력한 그 결과는 `[3, 100, 6]` 이다.

- 리스트에서 여러개 원소의 수정 

리스트에 속한 연속되는 범위 내의 원소들을 모두 수정 하는 방법 이다. 

```py 
# 리스트에서 연속적 원소들을 수정 하기
elist = [4, 5, 6, 7]
elist[1:2] = ['a', 'b']
print(elist)
``` 

위에서 `elist`리스트에서 `1`번째 인덱스 부터 `2` 까지의 인덱스에 `['a', 'b']` 리스트를 대입 한다. 1번부터 2번까지 라는 것은 2번을 포함 하지 않는 1번째 인덱스를 뜻 한다. 그러므로 `elist`에서 1번째 인덱스인 `5`를 수정 한다. 

실행 한 결과는 `[4, 'a', 'b', 6, 7]` 이다. `5`원소를 대입 된 리스트로 변경되었음을 확인 할 수 있다. 

그렇다면 위와 동일 한 결과를 얻게 될 거라고 예측 되는 `elist` 리스트에서 1번째 인덱스에 직접적으로 위와 같이 배열을 대입 시켜서 수정 하면 어떻게 될까? 아래와 같은 소스를 실행 시켜 보자. 

```py
elist = [4, 5, 6, 7]
elist[1] = ['a', 'b']
print(elist)
```

위를 실행 시키면 `[4, ['a', 'b'], 6, 7]`의 결과를 얻을 수 있다. 1번째 인덱스의 값이 수정 되기는 했 지만 리스트가 그대로 대입 된 것을 확인 할 수 있다. 

리스트의 원소를 수정 하려 할때에는 조심히 접근 해야 한다. 특히 리스트원소에 다른 리스트를 대입 하여 수정 할 때에는 더 조심히 사용 해야 한다. 

- 리스트에서 원소들을 삭제 

리스트에서 특정 원소들을 일괄적으로 제거 할 때에는 아래와 같은 방법으로 제거 한다. 

```py
# 리스트에서 원소를 삭제 하기
elist = [4, 5, 6, 7, 8, 9]
elist[1:3] = []
print(elist)
```

`elist`에서 1번째 부터 3번째 인덱스 까지의 원소들에 비어있는 리스트인 `[]`를 대입 하여 삭제 한다. 결과는 `[4, 7, 8, 9]` 이다. 

- 리스트에서 하나의 원소를 삭제 

`del`이라는 함수를 이용 하여 리스트의 원소를 제거 한다. 사용법은 아래와 같다. 

```py
# 리스트에서 원소를 삭제
elist = [4, 5, 6, 7]
del elist[1]
print(elist)
```

`elist`에서 1번째 인덱스의 원소를 `del`함수를 이용 하여 제거 한다. 결과는 `[4, 6, 7]` 이다. 

- 리스트의 정렬 

리스트의 원소의 순서에 따라서 정렬을 하고 싶으면 리스트의 `sort()`함수를 이용 하여 정렬 한다. 이 정렬 방법은 숫자나 문자 모두 지원 된다. 사용 방법은 다음과 같다. 

```py 
# 리스트의 정렬
numList = [4, 2, 12, 8, 5, 1, 3]
numList.sort()
print(numList)

textList = ['r', 'Kim', 'jung', 'B', 'c', 'b', 'Zed', 'a']
textList.sort()
print(textList)
```

리스트를 만들고 리스트에 대해서 `.`을 이용 하여 `sort()`함수를 호출 하여 리스트를 정렬 시키고 있다. 지금은 오름차순만 정렬 하도록 한다. 결과는 아래와 같다. 

```
[1, 2, 3, 4, 5, 8, 12]
['B', 'Kim', 'Zed', 'a', 'b', 'c', 'jung', 'r']
``` 

- 리스트 뒤집기 

주어진 리스트를 `reverse()`함수를 이용 하여 역으로 뒤집는다. 이는 역순으로 정렬 하는게 아니라 주어진 원소들을 단순히 역으로 뒤집어 주는 것 뿐 이다. 
예제는 다음과 같다. 

```py 
# 리스트 뒤집기
elist = [1, 2, 3, 4]
elist.reverse()
print(elist)
```

결과는 `[4, 3, 2, 1]` 이다. 원소들이 역으로 뒤집힌 것을 확인 할 수 있다. 

- 리스트에서 원소를 찾고 존재시 인덱스를 얻기 

리스트에서 어떠한 원소가 있는지, 그리고 그 원소의 위치가 어디에 있는지 확인할 필요가 있다. 그 방법 으로는 `index()`라는 함수를 이용 하여 검색 한다. 

```py 
# 원소 탐색 하고 인덱스 얻기
elist = [11, 22, 33, 44]
print(elist.index(22))
slist = ['abc', 'kim', 'lee', 'park']
print(slist.index('abc'))
print(slist.index('zzzz'))      # 없을 경우
```

`index()`함수를 이용 하여 리스트의 원소를 찾고 그에 대해서 원소의 리스트내에서 인덱스 위치를 얻고 이를 출력 하는 소스 이다. 마지막 `index()`의 경우 일부로 틀린 값을 주어 리스트에서 존재 하지 않는 원소를 찾아보라고 한 경우도 있다. 이들의 결과는 다음과 같다. 

```
1
0
Traceback (most recent call last):
  File "studyList.py", line 75, in <module>
    print(slist.index('zzzz'))      # 없을 경우
ValueError: 'zzzz' is not in list
```

첫번째의 결과로 `22`를 찾는데 1번째 인덱스에 있으니 1을 반환 하여 출력 하였다. 두번째의 경우 `abc`라는 문자열을 찾는데 0번째 인덱스에 있기 때문에 0을 반환하여 출력 하였다. 

그러나 마지막 테스트 코드의 경우 문자열 리스트인 `slist`에 존재 하지 않는 `zzzz`라는 문자열을 검색 하니 오류가 발생 한다. `ValueError: zzzz is not in list` 라는 오류를 확인 할 수 있다. 그렇기 때문에 리스트에서 원소에 탐색은 조심히 사용 해야 한다. 

- 리스트에 원소를 원하는 위치에 추가 하기 

리스트에서 원소를 추가 하기 위해서는 `insert()`라는 함수를 이용 하여 삽입 한다. 이 함수에서 첫번째 패러미터로 사용 되는 값은 추가할 원소의 위치 인덱스 이며, 두번째 패러미터는 삽입할 값 이다. 예제 소스는 아래와 같다. 

```py
testlist = [1, 2, 3, 4, 5]
# 원소 삽입
testlist.insert(0, -1)  # 0번째 인덱스에 `-1`을 삽입
print(testlist)
testlist.insert(6, 999) # 6번째 인덱스에 `999`를 삽입
print(testlist)
testlist.insert(1000, 0)    # 1000번째 인덱스에 0 을 삽입 -> 마지막에 추가 된다 
print(testlist)
```

위의 소스를 실행 하면 아래와 같다. 

```
[-1, 1, 2, 3, 4, 5]
[-1, 1, 2, 3, 4, 5, 999]
[-1, 1, 2, 3, 4, 5, 999, 0]
```

지정한 인덱스에 값들이 삽입된 것을 확인 할 수 있다. 그 중 `1000`번째 인덱스에 원소를 삽입 하는 내용이 있다. 실제 리스트에서는 1000개째의 원소 인덱스가 없기 때문에 오류가 날 수 도 있을거라고 생각 했지만 리스트의 마지막 원소로 추가 되는 것 을 확인 할 수 있다. 

- 리스트에서 특정 원소를 제거 하기 

리스트에서 특정한 원소를 제거 하려면 `remove()` 함수를 사용 하면 되는데 특정한 원소를 탐색 하고 가장 먼저 발견되는 원소를 제거 하는 함수이다. 우선 예제 소스를 보도록 하자. 

```py 
testlist = [1, 2, 3, 1, 4, 5]
# 원소 제거
testlist.remove(1)  # `1` 라는 원소들 중 가장 먼저 찾는 원소를 제거
print(testlist)
testlist.remove(4)  # `4`라는 원소를 찾아서 제거
print(testlist)
# 찾아서 제거할 원소가 없을 경우 오류가 발생 한다.
```

위의 원소 중 `1`은 두개가 존재 한다. `remove(1)`함수를 이용 하여 `1`이라는 원소를 찾아 리스트에서 제거 한다. 아무튼 결과는 다음과 같다. 

```
[2, 3, 1, 4, 5]
[2, 3, 1, 5]
```

원소들 중에서 `1`을 가장 먼저 찾은 원소를 제거 한다. 결국 `0`번째 인덱스에 위치한 값을 제거 한 것 을 확인 할 수 있다. 

- 리스트에서 마지막 원소를 제거 하고 얻기 

`pop()`함수를 이용 하여 리스트의 원소들 중 가장 마지막 원소를 얻고 리스트에서 제거 한다. 

```py 
testlist = [1, 2, 3, 4, 5]
# 마지막 원소 얻고 제거
testlist.pop()
print(testlist)
element = testlist.pop()
print(testlist)
print(element)
```

실행결과는 다음과 같다. 

```
[1, 2, 3, 4]
[1, 2, 3]
4
```

`pop()` 함수는 리스트에 저장된 원소들 중 마지막 원소를 얻고 리스트에서 제거 한다. 그리고 `pop()`함수에서 반환되는 것은 리스트에서 `pop`연산 후에 얻게 되는 리스트에서 제거 될 마지막 원소 이다. 위 예제 소스에서 마지막 원소였던 `4`를 리스트에서 `pop`연산 하는 것 을 확인 할 수 있다. 

`pop`연산 이라는것은 `stack` 자료 구조에서 어떠한 특정 연산 이다. 이러한 것은 따로 공부 할 수 있다. 

- 리스트에서 특정 원소의 갯수 얻기 

주어진 리스트에서 특정한 원소가 존재 하면 `count()`함수를 이용 하여 해당 원소의 갯수를 얻는다. 주어지는 패러미터는 찾을 원소의  값 이다. 

```py 
testlist = [1, 2, 1, 3, 1, 4, 3, 5]
# 원소의 갯수 세기
print(testlist.count(1))
print(testlist.count(3))
print(testlist.count(5))
print(testlist.count(-1))
```

결과는 아래와 같다. 

```
3
2
1
0
``` 

주어진 패러미터의 값을 리스트에서 찾고 그 갯수가 몇개인지를 출력 하였다. 만약 찾는 원소가 리스트에 존재하지 않는다면 `0`을 반환 한다. 

- 리스트에 원소들이 존재 하는 리스트를 추가 하여 확장 하기 

`extend([리스트])` 함수를 이용 하여 리스트에 리스트를 추가 하여 확장 하듯이 사용 할 수 있다. 

```py 
# 리스트의 확장
testlist = [1, 2, 3]
extlist = [4, 5]
testlist.extend(extlist)
print(testlist)

testlist = [1, 2, 3]
extlist = [4, 5]
testlist += extlist   # testlist = testlist + extlist
print(testlist)

testlist = [1, 2, 3]
testlist.extend([4, 5])
print(testlist)
```

위의 실행 결과는 모두 동일 하다. 그 결과는 다음과 같다. 

```
[1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
```

## 2. 튜플 (Tuple)

튜플은 리스트와 동일하게 어떠한 데이터들의 선형적인 모음 이라고 할 수 있다. 예제로 다음과 같이 사용 한다. 

```py
t = (1, 2, 3, 4, 5)
print(t) 
```

실행 결과는 `(1, 2, 3, 4, 5)` 이다. 리스트와 사용 법이 거의 동일 하지만 원소들의 집합을 둘러 싸는 문자가 `[]`가 아니라 `()`임을 확인 할 수 있다. 그렇다면 리스트와 튜플은 비슷해 보이는데 왜 이렇게 다른 방식으로 구현 되며 이름까지도 다른 것 일까? 

- 리스트와 튜플의 다른 점 

리스트를 만들고 난 뒤에는 언제든지 원소들을 수정, 삭제, 추가 할 수 있다. 이렇게 수정이 계속 가능한 데이터 형을 `muttable (가변형)`이라고 한다. 

하지만 튜플 자료구조형은 리스트와는 다르게 최초에 생성한 원소들의 값을 수정 할 수 없다. 최초에 생성한 원소들의 목록 그대로 변하지 않고 사용 해야 한다. 이러한 데이터의 형태를 `immutable (불변형)`이라고 한다. JAVA언어에서 `String (immutable type)` 과 `StringBuilder`의 차이점을 알고 있다면 이해하기 쉽다. 

아래의 예제 소스를 보면 이해하기 더 쉽다. 

```py 
t1 = (1,)   # 단 한개의 원소만 가졌을 경우에도 ,를 붙인다
print(t1)

t = (1, 2, 3, 4, 5)
print(t)

t[2] = 100
print(t)        # 데이터를 수정 하려 하니 오류 발생 한다. 

del t[2]        # 원소 삭제 시도시 오류

tmp = (95, 96)
t += tmp        # append() 함수가 없음
print(t)

tstr = ("kang", "lee", "park", "kim", "lee", "jung")
print(tstr.index("park"))       # 2 출력 (2번째 인덱스에 위치)
print(tstr.count("lee"))        # `lee`라는 문자열이 2개 존재
print(tstr[2:])                 # `park` 부터 마지막 원소 까지 출력
``` 

리스트와 튜플 중에서 어떤 자료구조형을 사용 해야 하는가에 대해서 고민 할 경우에는 원소 데이터를 미리 다 알고 있거나 수정 할 일이 없는 경우에는 튜플을 사용 하고 그 외 모든 경우에는 리스트를 사용 하면 된다. 추 후 배울 딕셔너리도 고민 하면된다 하겠다. 

리스트와 동일 하게 `+` 연산이나 `*`은 동일 하다. 몰론 인덱싱을 이용 한 원소의 접근 과 잘라내는 것도 동일 하게 사용 하면 된다. 다만 튜플은 리스트와는 다르게 원소의 수정이나 삭제를 지원하지 않으므로 이에 대해서만 유의해서 사용 하면 된다. 

## 3. 딕셔너리 (Dictionarie) 

딕셔너리는 리스트와 튜플하고는 다른 구조를 갖고 있다. 리스트나 튜플 에서는 원소들의 집합 이었지만 딕셔너리의 경우에는 실제원소를 설명 하는 `Key`와 그에 해당 하는 값인 `Value`로 구분 된다. 

리스트나 튜플의 경우 순차적인 선형적 자료구조를 갖지만 딕셔너리는 key 를 이용 하여 value 를 얻는 구조 이다. 이는 사전과 비슷 하다고 할 수 있겠다. 사전에서 찾는 단어를 검색 하기 위해 앞글자를 찾던 것을 생각 해 보자. `hello`라는 단어를 사전에서는 찾기 위해서는 `h`라는 문자의 영역에 가야 한다. 여기에서 key 는 `h`이고 그 값은 `hello`라고 할 수 있겠다. 딕셔너리의 자료 구조는 이러한 `key-value`구조를 갖는다. 

이러한 key-value 자료구조는 리스트같은 선형구조와는 다른 장단점을 갖고 있다. 우선 그 장점중 하나로는 검색이나 탐색의 경우 일반 리스트보다는 훨씬 더 빠르다. 예를 들어 위에 설명한 `hello`라는 값을 찾기 위해서는 앞글자인 `h` 키만 검색 하고 그 키에 해당 하는 value 만 검색하면 되기 때문이다. 만약 선형적인 자료구조의 경우에는 0번째 인덱스 부터 어디에 존재하는지 알 수 없는 위치 까지 계속 검색 해야 하기 때문에 최악의 경우 느릴 수 밖에 없다. 

주의할 점은 딕셔너리에서 사용 되는 키 고유한 값으로서 중복되어 저장 할 수 없다. 

- 딕셔너리의 기본 사용 예 



```py
dic = {'name':'Kang', 'email':'kang1010@google.com', 'phone':'01012345678'}
print(dic)
```

# 4. 셋 (Set)

