# Java Collections 

자바에서 사용되는 컬렉션은 그 종류도 많아 모든 자료구조를 알기는 힘들다. 제대로 된 설계를 하기 위해서는 상황에 맞추어 필요한 자료구조들에 대해서 잘 알고 있어야 한다. 

![java_collections](https://github.com/ksu3101/TIL/blob/master/DS/image/java_collections.jpg)

아래의 자료구조들은 *Collections* 인터페이스를 구현하거나 상속받은 인터페이스 혹은 클래스 이다. 

우선 기본적인 *List*, *Set*, *Map*, *Queue*의 자료 구조에 대한 설명은 다음과 같다. 

이름 | 중복허용 |  설명 
--- | --- | ---
*`List`* | O | **순서가 있는** 데이터들의 집합 이며 **중복을 허용** 함. 
*`Set`* | X | **순서가 없는** 데이터들의 집합 이며 **중복을 허용 하지 않음**. 
*`Map`* | - | **Key-Value Pair**로 구성된 데이터의 집합. **Key의 중복을 허용하지 않으며** 이를 이용하여 검색 할 수 있음.  
*`Queue`* | O | **FIFO (선입선출)** 구조. 

주로 사용되어지는 자료구조들은 위 의 인터페이스를 구현한 형태 이다.  

구분 | 이름 | 동기화 | 설명  
--- | --- | --- | --- | ---
*`List`*  | `ArrayList` | X | 동적으로 전체의 크기가 변하는 배열. 
*`List`*  | `LinkedList` | X | 원소의 추가, 삭제 연산이 상대적으로 좋음.  `Queue`의 구현에 사용.  
*`List`*  | `Vector` | O | **동기화(synchronized)**를 적용 하여 `List`에서는 낮은 퍼포먼스. 
*`List`*  | `Stack` | O | `Vector`이용하여 만듬. 그래서 동기화 되어 있음. **LIFO (후입선출)** 구조.
*`Set`*  | `HashSet` | X | 가장 빠른 원소의 임의 접근 속도를 갖고 있음. `HashMap`보다 느리다.    
*`Set`*  | `TreeSet (SortedSet)` | X | 내부 데이터를 정렬하여 저장. `Red-Black Tree`알고리즘 참고.
*`Map`*  | `HashMap` | X | 입력한 순서를 보장하지 않음. 
*`Map`*  | `LinkedHashMap` | X | 입력한 순서를 보장. 
*`Map`*  | `HashTable` | O | `HashMap`보다 느림. 
*`Map`*  | `TreeMap (SortedMap)` | X | 내부 데이터를 정렬하여 저장. `Red-Black Tree`알고리즘 참고.
*`Queue`*  | `PriorityQueue` | X | 우선순위 큐. 
*`Queue`*  | `PriorityBlockingQueue` | O | 우선순위 큐에 동기화 적용. 

